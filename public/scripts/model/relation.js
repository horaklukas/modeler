// Generated by CoffeeScript 1.6.2
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

goog.provide('dm.model.Relation');

goog.require('goog.math.Coordinate');

goog.require('goog.graphics.Path');

goog.require('goog.graphics.Stroke');

dm.model.Relation = (function() {
  /**
   * @constructor
   *
   * @param {dm.ui.Canvas} canvas Place where to draw relation
   * @param {string} id Relation identificator
   * @param {dm.model.Table} startTab First ("parent") table of relation
   * @param {dm.model.Table} endTab Second ("child") table of relation
   * @param {boolean=} ident Determine if relation is identifying
  */
  function Relation(canvas, id, startTab, endTab, ident) {
    var stroke;

    this.id = id;
    if (ident == null) {
      ident = false;
    }
    this.getRelationPoints = __bind(this.getRelationPoints, this);
    this.getPathPosition = __bind(this.getPathPosition, this);
    this.setRelatedTables = __bind(this.setRelatedTables, this);
    this.setRelatedTables(startTab, endTab);
    stroke = new goog.graphics.Stroke(2, '#000');
    this.obj = canvas.drawPath(this.getPathPosition(), stroke);
    this.obj.getElement().setAttribute('id', id);
    this.setIdentifying(ident);
  }

  Relation.prototype.recountPosition = function() {
    return this.obj.setPath(this.getPathPosition());
  };

  Relation.prototype.setRelatedTables = function(parent, child) {
    this.startTab = parent;
    return this.endTab = child;
  };

  /**
  	* @param {boolean} ident Determine if relation is identyfing
  */


  Relation.prototype.setIdentifying = function(ident) {
    this.identifying = ident;
    if (ident) {
      return this.obj.getElement().removeAttribute('stroke-dasharray');
    } else {
      return this.obj.getElement().setAttribute('stroke-dasharray', '10 5');
    }
  };

  /**
  	* @return {boolean}
  */


  Relation.prototype.isIdentifying = function() {
    return this.identifying;
  };

  /**
   * @return {goog.graphics.Path} new path that represents the relation
  */


  Relation.prototype.getPathPosition = function() {
    var path, points;

    points = this.getRelationPoints();
    path = new goog.graphics.Path();
    path.moveTo(points.start.x, points.start.y);
    path.lineTo(points.break1.x, points.break1.y);
    if (!goog.math.Coordinate.equals(points.break2, points.break1)) {
      path.lineTo(points.break2.x, points.break2.y);
    }
    return path.lineTo(points.stop.x, points.stop.y);
  };

  /**
   * @return {Object.<string,goog.math.Coordinate>}
  */


  Relation.prototype.getRelationPoints = function() {
    var breaks, dist, dists, distsPoint, eCoord, ePos, eTab, result, sCoord, sPos, sTab, start, stop;

    sTab = this.startTab.getConnPoints();
    eTab = this.endTab.getConnPoints();
    dists = [];
    distsPoint = [];
    for (sPos in sTab) {
      sCoord = sTab[sPos];
      for (ePos in eTab) {
        eCoord = eTab[ePos];
        dist = this.getPathDistance(sPos, sCoord, ePos, eCoord);
        if (dist !== false) {
          dists.push(dist);
          distsPoint[dist] = [sPos, ePos];
        }
      }
    }
    if (dists.length === 0) {
      result = ['top', 'top'];
    } else {
      result = distsPoint[Math.min.apply(Math, dists)];
    }
    start = sTab[result[0]];
    stop = eTab[result[1]];
    breaks = this.getBreakPoints(start, result[0], stop, result[1]);
    return {
      start: start,
      break1: breaks[0],
      break2: breaks[1],
      stop: stop
    };
  };

  /**
   *
   * @param {string} pos1
   * @param {goog.math.Coordinate} coord1
   * @param {string} pos2
   * @param {goog.math.Coordinate} coord2
   * @return {number|boolean} returns number of distance, if it's possible from
   * points position else return false
  */


  Relation.prototype.getPathDistance = function(pos1, coord1, pos2, coord2) {
    if (pos1 === pos2 || (((pos1 !== 'right' && pos2 !== 'left') || coord1.x < coord2.x) && ((pos1 !== 'left' && pos2 !== 'right') || coord1.x > coord2.x) && ((pos1 !== 'bottom' && pos2 !== 'top') || coord1.y < coord2.y) && ((pos1 !== 'top' && pos2 !== 'bottom') || coord1.y > coord2.y))) {
      return Math.abs(coord1.x - coord2.x) + Math.abs(coord1.y - coord2.y);
    } else {
      return false;
    }
  };

  /**
   *
   * @param {goog.math.Coordinate} start Relation start point coordinates
   * @param {string} sPos Position of start relation point
   * @param {goog.math.Coordinate} end Relation end point coordinates
   * @param {string} ePos Position of end relation point
   * @return {Array.<goog.math.Coordinate>} Two relation break points
  */


  Relation.prototype.getBreakPoints = function(start, sPos, end, ePos) {
    var b1, b2, horiz, vert, x, y;

    horiz = ['left', 'right'];
    vert = ['top', 'bottom'];
    if (__indexOf.call(horiz, sPos) >= 0 && __indexOf.call(horiz, ePos) >= 0) {
      x = ((end.x - start.x) / 2) + start.x;
      b1 = new goog.math.Coordinate(x, start.y);
      b2 = new goog.math.Coordinate(x, end.y);
    } else if (__indexOf.call(vert, sPos) >= 0 && __indexOf.call(vert, ePos) >= 0) {
      y = ((end.y - start.y) / 2) + start.y;
      b1 = new goog.math.Coordinate(start.x, y);
      b2 = new goog.math.Coordinate(end.x, y);
    } else {
      if (sPos === 'right' || sPos === 'left') {
        b1 = b2 = new goog.math.Coordinate(end.x, start.y);
      }
      if (ePos === 'right' || ePos === 'left') {
        b1 = b2 = new goog.math.Coordinate(start.x, end.y);
      }
    }
    console.log(sPos, ePos, b1, b2);
    return [b1, b2];
  };

  return Relation;

})();

if (typeof window === "undefined" || window === null) {
  module.exports = Relation;
}
